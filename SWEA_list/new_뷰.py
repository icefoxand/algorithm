# ▷ 임 강사님: 반복문 쓸때 인덱스를 for i in range()로 바꿔서 해보라

# SWEA_View
# 구미2반_최지원_작성

# ●구해야 할 것: 조망권이 확보된 세대(칸) 수를 구하기

T = 10 # 이미 전체 테스트케이스 수가 10으로 정해져 있어서, T=10으로 선언해준다
for tc in range(1,1+T): # tc가 1~10 사이를 돌면서 하나씩 나오게 만든다
    N = int(input()) # 각 테스트케이스별로 숫자 배열의 총 수를 인트로 변경해 받아준다
    data = list(map(int,input().split())) # 주어진 숫자 배열을, int로 구성된 list로 변경하여 입력받는다.
    answer = 0 # 최종정답을 받을 answer을 0으로 선언한다. 기본 인덱스i가 도는 중간에 초기화 되면 안되므로, 포문 위쪽에 선언함
    for i in range(2,N-2): # i가 양끝의 2칸을 제외하고 돌아야 하므로, 인덱스 2부터 N-3까지를 돌도록 반복문 범위를 설정한다
        # 기본인덱스 i 가 돌면서 i-2,i-1,i+1,i+2번째 높이를 보조적으로 가져가야 한다
        # 보조인덱스 들을 담을 리스트 l을 선언한다. i가 바뀔때마다 l을 초기화 해야 하므로, i 포문 아래에 초기화를 한다.
        # 리스트l의 최댓값을 담기 위한 인트 변수 max_l을 선언한다. 이또한 같은 원리로, 리스트 l과 같은 위치에 둔다.
        l = []
        max_l = 0
        for j in [-2,-1,+1,+2]:
            l.append(data[i+j]) # [i+j] 인덱스를 이용해서 i의 좌우 +2,+1,-1,-2 위치에 해당하는 데이터값(높이)을 l에 추가함
        for k in range(4): # 리스트 l에 포함된 원소가 4개씩 이므로, 그 원소들의 최댓값을 찾는 반복문을 돌린다.
            if max_l < l[k]: # 민맥스 문제처럼, 초기에 설정한 최댓값 변수보다 현재 l[k]값이 더 크다면, 최댓값을 갱신한다
                max_l = l[k]
        if data[i]>max_l: # max_l보다 data[i]가 더 크다면, 그 차이를 정답 변수 answer 에 담는다.
            answer += data[i]-max_l

    print(f'#{tc} {answer}') # 정답을 출력한다
#####요청받은 부분 다시풀어보기

